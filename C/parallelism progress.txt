without any parallelism:
	49 s
	49 s
	50 s

1 thread for each call to isColorIso, run serially:
	221 s but work load is spread over all cores
	237 s

1 thread for every call to iscoloriso for a particular current graph, run concurrently:
	249 s


1 thread
	55 s

2 threads
	35 s
	35 s
	29 s @ 4.4 GHz

3 threads
	21 s @ 4.4 GHz
4 threads at a time, one for each raw graph
	44 s
	42 s
	40 s
	37 s

	21 s at 4.4 GHz
5 threads
	20 s at 4.4
4 threads 26

10 threads at a time
	 24 s
	 24 s
	 19 s at 4.4 GHz
	 20 s at 4.4 GHz

16 threads 20 s

25 threads
	26 s

100 threads
	35 s



Single Threaded:
	~450 g/s
	33s

Multi Threaded Slices:
	1 thread:
		~360 g/s
		47s
	2 threads:
		~300 g/s @ 10s
		26s
	3 threads:
		~270 g/s
		18s
	4 threads:
		~230 g/s
		14s


The idea:
	Sort the graphs, and scan for blocks, at least BlockSize big. Add the indecies of
	the first graph to a stack.
	Then the threads take blocks from the stack using a mutex, and process, until
	they've cleaned enough that BlockSize graphs are validated. Rinse and repeat.
	Threads have to be changed to efficiently use their sorted qualities.

Current:
for g in block:
    for other h in block:
        Run through all permutations of g
				for each permutation:
        	if match with h, return true and break
					else return false and match

Or
for g in block:
    run through all permutations of g
		for each permutation:
	    for each other h in block:
	        if match, remove h
